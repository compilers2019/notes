before c++-11 c++ programmers had no standardized ways to work with threads, they were limited to Qt and using non portable system calls.

since c++-11 we have parallel programing in stdlib.

<thread>
<mutex>
<conditional_variable>
<future>
<atomic>

who to blame?
programmer?
compiler?

though the routines to deal with multithreaded programming
are in stdlib now

multithreading is not reflected in the standard.
compiler believes that it generates code for single process on an abstract machine. thus it can apply optimizations, that should not affect work on one cpu.


In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one "single" instance. This is useful when exactly one object is needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton.

Եզակի օգտագործման նախագծման ձևանմուշը ստեղծող ձևանմուշ է, որը միահոսքային ծրագրերում գլոբալ հասանելիության տեսանկյունից հանդիսանում է դասի եզակի նմուշը։ Ձևանմուշի օգտագործումը օգտակար է կիրառել, երբ ողջ համակարգի մեջ միայն մի օբյեկտ պետք է կոորդինացնել։

Singleton* Singleton::Get()
{

 if (instance == nullptr)
 {
   std::lock_guard<std::mutex> guard(lock);
   if (instance == nullptr
   {
     instance = new Singleton();
   }


 }
 return instance;
}

mutex is an expensive operation.

this code may not work in threaded environment.
